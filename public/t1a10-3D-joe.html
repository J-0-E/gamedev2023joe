<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - lights - hemisphere light</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			body {
				color: #444;
			}
			a {
				color: #08f;
			}
		</style>
	</head>
	<body>

		<div id="container"></div>
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - webgl hemisphere light example<br/>
			flamingo by <a href="https://mirada.com/" target="_blank" rel="noopener">mirada</a> from <a href="http://www.ro.me" target="_blank" rel="noopener">ro.me</a>
		</div>

		<script type="x-shader/x-vertex" id="vertexShader">

			varying vec3 vWorldPosition;

			void main() {

				vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
				vWorldPosition = worldPosition.xyz;

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentShader">

			uniform vec3 topColor;
			uniform vec3 bottomColor;
			uniform float offset;
			uniform float exponent;

			varying vec3 vWorldPosition;

			void main() {

				float h = normalize( vWorldPosition + offset ).y;
				gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h , 0.0), exponent ), 0.0 ) ), 1.0 );

			}

		</script>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import Stats from 'three/addons/libs/stats.module.js';
			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

			let camera, scene, renderer;
			const mixers = [];
			let stats;

			const clock = new THREE.Clock();

			init();
			animate();

			function init() {

				const container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 5000 );
				camera.position.set( 0, 0, 250 );

				scene = new THREE.Scene();
				scene.background = new THREE.Color().setHSL( 0.6, 0, 1 );
				scene.fog = new THREE.Fog( scene.background, 1, 5000 );

				// LIGHTS

				const hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 2 );
				hemiLight.color.setHSL( 0.6, 1, 0.6 );
				hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
				hemiLight.position.set( 0, 50, 0 );
				scene.add( hemiLight );

				const hemiLightHelper = new THREE.HemisphereLightHelper( hemiLight, 10 );
				scene.add( hemiLightHelper );

				//

				const dirLight = new THREE.DirectionalLight( 0xffffff, 3 );
				dirLight.color.setHSL( 0.1, 1, 0.95 );
				dirLight.position.set( - 1, 1.75, 1 );
				dirLight.position.multiplyScalar( 30 );
				scene.add( dirLight );

				dirLight.castShadow = true;

				dirLight.shadow.mapSize.width = 2048;
				dirLight.shadow.mapSize.height = 2048;

				const d = 50;

				dirLight.shadow.camera.left = - d;
				dirLight.shadow.camera.right = d;
				dirLight.shadow.camera.top = d;
				dirLight.shadow.camera.bottom = - d;

				dirLight.shadow.camera.far = 3500;
				dirLight.shadow.bias = - 0.0001;

				const dirLightHelper = new THREE.DirectionalLightHelper( dirLight, 10 );
				scene.add( dirLightHelper );

				// GROUND

				const groundGeo = new THREE.PlaneGeometry( 10000, 10000 );
				const groundMat = new THREE.MeshLambertMaterial( { color: 0xffffff } );
				groundMat.color.setHSL( 0.095, 1, 0.75 );

				const ground = new THREE.Mesh( groundGeo, groundMat );
				ground.position.y = - 33;
				ground.rotation.x = - Math.PI / 2;
				ground.receiveShadow = true;
				scene.add( ground );

				// SKYDOME

				const vertexShader = document.getElementById( 'vertexShader' ).textContent;
				const fragmentShader = document.getElementById( 'fragmentShader' ).textContent;
				const uniforms = {
					'topColor': { value: new THREE.Color( 0x0077ff ) },
					'bottomColor': { value: new THREE.Color( 0xffffff ) },
					'offset': { value: 33 },
					'exponent': { value: 0.6 }
				};
				uniforms[ 'topColor' ].value.copy( hemiLight.color );

				scene.fog.color.copy( uniforms[ 'bottomColor' ].value );

				const skyGeo = new THREE.SphereGeometry( 4000, 32, 15 );
				const skyMat = new THREE.ShaderMaterial( {
					uniforms: uniforms,
					vertexShader: vertexShader,
					fragmentShader: fragmentShader,
					side: THREE.BackSide
				} );

				const sky = new THREE.Mesh( skyGeo, skyMat );
				scene.add( sky );

				// MODEL

				const loader = new GLTFLoader();

				loader.load( 'models/gltf/Flamingo.glb', function ( gltf ) {

					const mesh = gltf.scene.children[ 0 ];

					const s = 0.35;
					mesh.scale.set( s, s, s );
					mesh.position.y = 15;
					mesh.rotation.y = - 1;

					mesh.castShadow = true;
					mesh.receiveShadow = true;

					scene.add( mesh );

					const mixer = new THREE.AnimationMixer( mesh );
					mixer.clipAction( gltf.animations[ 0 ] ).setDuration( 1 ).play();
					mixers.push( mixer );

				} );

				// RENDERER

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );
				renderer.shadowMap.enabled = true;

				// STATS

				stats = new Stats();
				container.appendChild( stats.dom );

				//

				const params = {
					toggleHemisphereLight: function () {

						hemiLight.visible = ! hemiLight.visible;
						hemiLightHelper.visible = ! hemiLightHelper.visible;

					},
					toggleDirectionalLight: function () {

						dirLight.visible = ! dirLight.visible;
						dirLightHelper.visible = ! dirLightHelper.visible;

					}
				};

				const gui = new GUI();

				gui.add( params, 'toggleHemisphereLight' ).name( 'toggle hemisphere light' );
				gui.add( params, 'toggleDirectionalLight' ).name( 'toggle directional light' );
				gui.open();

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				const delta = clock.getDelta();

				for ( let i = 0; i < mixers.length; i ++ ) {

					mixers[ i ].update( delta );

				}

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - lights - physical lights</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="container"></div>
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - Physically accurate incandescent bulb by <a href="http://clara.io" target="_blank" rel="noopener">Ben Houston</a><br />
			Real world scale: Brick cube is 50 cm in size. Globe is 50 cm in diameter.<br/>
			Reinhard inline tonemapping with real-world light falloff (decay = 2).
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import Stats from 'three/addons/libs/stats.module.js';
			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			let camera, scene, renderer, bulbLight, bulbMat, hemiLight, stats;
			let ballMat, cubeMat, floorMat;

			let previousShadowMap = false;


			// ref for lumens: http://www.power-sure.com/lumens.htm
			const bulbLuminousPowers = {
				'110000 lm (1000W)': 110000,
				'3500 lm (300W)': 3500,
				'1700 lm (100W)': 1700,
				'800 lm (60W)': 800,
				'400 lm (40W)': 400,
				'180 lm (25W)': 180,
				'20 lm (4W)': 20,
				'Off': 0
			};

			// ref for solar irradiances: https://en.wikipedia.org/wiki/Lux
			const hemiLuminousIrradiances = {
				'0.0001 lx (Moonless Night)': 0.0001,
				'0.002 lx (Night Airglow)': 0.002,
				'0.5 lx (Full Moon)': 0.5,
				'3.4 lx (City Twilight)': 3.4,
				'50 lx (Living Room)': 50,
				'100 lx (Very Overcast)': 100,
				'350 lx (Office Room)': 350,
				'400 lx (Sunrise/Sunset)': 400,
				'1000 lx (Overcast)': 1000,
				'18000 lx (Daylight)': 18000,
				'50000 lx (Direct Sun)': 50000
			};

			const params = {
				shadows: true,
				exposure: 0.68,
				bulbPower: Object.keys( bulbLuminousPowers )[ 4 ],
				hemiIrradiance: Object.keys( hemiLuminousIrradiances )[ 0 ]
			};

			init();
			animate();

			function init() {

				const container = document.getElementById( 'container' );

				stats = new Stats();
				container.appendChild( stats.dom );


				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.x = - 4;
				camera.position.z = 4;
				camera.position.y = 2;

				scene = new THREE.Scene();

				const bulbGeometry = new THREE.SphereGeometry( 0.02, 16, 8 );
				bulbLight = new THREE.PointLight( 0xffee88, 1, 100, 2 );

				bulbMat = new THREE.MeshStandardMaterial( {
					emissive: 0xffffee,
					emissiveIntensity: 1,
					color: 0x000000
				} );
				bulbLight.add( new THREE.Mesh( bulbGeometry, bulbMat ) );
				bulbLight.position.set( 0, 2, 0 );
				bulbLight.castShadow = true;
				scene.add( bulbLight );

				hemiLight = new THREE.HemisphereLight( 0xddeeff, 0x0f0e0d, 0.02 );
				scene.add( hemiLight );

				floorMat = new THREE.MeshStandardMaterial( {
					roughness: 0.8,
					color: 0xffffff,
					metalness: 0.2,
					bumpScale: 0.0005
				} );
				const textureLoader = new THREE.TextureLoader();
				textureLoader.load( 'textures/hardwood2_diffuse.jpg', function ( map ) {

					map.wrapS = THREE.RepeatWrapping;
					map.wrapT = THREE.RepeatWrapping;
					map.anisotropy = 4;
					map.repeat.set( 10, 24 );
					map.colorSpace = THREE.SRGBColorSpace;
					floorMat.map = map;
					floorMat.needsUpdate = true;

				} );
				textureLoader.load( 'textures/hardwood2_bump.jpg', function ( map ) {

					map.wrapS = THREE.RepeatWrapping;
					map.wrapT = THREE.RepeatWrapping;
					map.anisotropy = 4;
					map.repeat.set( 10, 24 );
					floorMat.bumpMap = map;
					floorMat.needsUpdate = true;

				} );
				textureLoader.load( 'textures/hardwood2_roughness.jpg', function ( map ) {

					map.wrapS = THREE.RepeatWrapping;
					map.wrapT = THREE.RepeatWrapping;
					map.anisotropy = 4;
					map.repeat.set( 10, 24 );
					floorMat.roughnessMap = map;
					floorMat.needsUpdate = true;

				} );

				cubeMat = new THREE.MeshStandardMaterial( {
					roughness: 0.7,
					color: 0xffffff,
					bumpScale: 0.002,
					metalness: 0.2
				} );
				textureLoader.load( 'textures/brick_diffuse.jpg', function ( map ) {

					map.wrapS = THREE.RepeatWrapping;
					map.wrapT = THREE.RepeatWrapping;
					map.anisotropy = 4;
					map.repeat.set( 1, 1 );
					map.colorSpace = THREE.SRGBColorSpace;
					cubeMat.map = map;
					cubeMat.needsUpdate = true;

				} );
				textureLoader.load( 'textures/brick_bump.jpg', function ( map ) {

					map.wrapS = THREE.RepeatWrapping;
					map.wrapT = THREE.RepeatWrapping;
					map.anisotropy = 4;
					map.repeat.set( 1, 1 );
					cubeMat.bumpMap = map;
					cubeMat.needsUpdate = true;

				} );

				ballMat = new THREE.MeshStandardMaterial( {
					color: 0xffffff,
					roughness: 0.5,
					metalness: 1.0
				} );
				textureLoader.load( 'textures/planets/earth_atmos_2048.jpg', function ( map ) {

					map.anisotropy = 4;
					map.colorSpace = THREE.SRGBColorSpace;
					ballMat.map = map;
					ballMat.needsUpdate = true;

				} );
				textureLoader.load( 'textures/planets/earth_specular_2048.jpg', function ( map ) {

					map.anisotropy = 4;
					map.colorSpace = THREE.SRGBColorSpace;
					ballMat.metalnessMap = map;
					ballMat.needsUpdate = true;

				} );

				const floorGeometry = new THREE.PlaneGeometry( 20, 20 );
				const floorMesh = new THREE.Mesh( floorGeometry, floorMat );
				floorMesh.receiveShadow = true;
				floorMesh.rotation.x = - Math.PI / 2.0;
				scene.add( floorMesh );

				const ballGeometry = new THREE.SphereGeometry( 0.25, 32, 32 );
				const ballMesh = new THREE.Mesh( ballGeometry, ballMat );
				ballMesh.position.set( 1, 0.25, 1 );
				ballMesh.rotation.y = Math.PI;
				ballMesh.castShadow = true;
				scene.add( ballMesh );

				const boxGeometry = new THREE.BoxGeometry( 0.5, 0.5, 0.5 );
				const boxMesh = new THREE.Mesh( boxGeometry, cubeMat );
				boxMesh.position.set( - 0.5, 0.25, - 1 );
				boxMesh.castShadow = true;
				scene.add( boxMesh );

				const boxMesh2 = new THREE.Mesh( boxGeometry, cubeMat );
				boxMesh2.position.set( 0, 0.25, - 5 );
				boxMesh2.castShadow = true;
				scene.add( boxMesh2 );

				const boxMesh3 = new THREE.Mesh( boxGeometry, cubeMat );
				boxMesh3.position.set( 7, 0.25, 0 );
				boxMesh3.castShadow = true;
				scene.add( boxMesh3 );


				renderer = new THREE.WebGLRenderer();
				renderer.shadowMap.enabled = true;
				renderer.toneMapping = THREE.ReinhardToneMapping;
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );


				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 1;
				controls.maxDistance = 20;

				window.addEventListener( 'resize', onWindowResize );


				const gui = new GUI();

				gui.add( params, 'hemiIrradiance', Object.keys( hemiLuminousIrradiances ) );
				gui.add( params, 'bulbPower', Object.keys( bulbLuminousPowers ) );
				gui.add( params, 'exposure', 0, 1 );
				gui.add( params, 'shadows' );
				gui.open();

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();

			}

			function render() {

				renderer.toneMappingExposure = Math.pow( params.exposure, 5.0 ); // to allow for very bright scenes.
				renderer.shadowMap.enabled = params.shadows;
				bulbLight.castShadow = params.shadows;

				if ( params.shadows !== previousShadowMap ) {

					ballMat.needsUpdate = true;
					cubeMat.needsUpdate = true;
					floorMat.needsUpdate = true;
					previousShadowMap = params.shadows;

				}

				bulbLight.power = bulbLuminousPowers[ params.bulbPower ];
				bulbMat.emissiveIntensity = bulbLight.intensity / Math.pow( 0.02, 2.0 ); // convert from intensity to irradiance at bulb surface

				hemiLight.intensity = hemiLuminousIrradiances[ params.hemiIrradiance ];
				const time = Date.now() * 0.0005;

				bulbLight.position.y = Math.cos( time ) * 0.75 + 1.25;

				renderer.render( scene, camera );

				stats.update();

			}

		</script>
	</body>
</html>
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - lights - point lights</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - point lights WebGL demo.<br />
			Walt Disney head by <a href="http://web.archive.org/web/20120903131400/http://davidoreilly.com/post/18087489343/disneyhead" target="_blank" rel="noopener">David OReilly</a>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import Stats from 'three/addons/libs/stats.module.js';

			import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';

			let camera, scene, renderer,
				light1, light2, light3, light4,
				object, stats;

			const clock = new THREE.Clock();

			init();
			animate();

			function init() {

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.z = 100;

				scene = new THREE.Scene();

				//model

				const loader = new OBJLoader();
				loader.load( 'models/obj/walt/WaltHead.obj', function ( obj ) {

					object = obj;
					object.scale.multiplyScalar( 0.8 );
					object.position.y = - 30;
					scene.add( object );

				} );

				const sphere = new THREE.SphereGeometry( 0.5, 16, 8 );

				//lights

				light1 = new THREE.PointLight( 0xff0040, 400 );
				light1.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0xff0040 } ) ) );
				scene.add( light1 );

				light2 = new THREE.PointLight( 0x0040ff, 400 );
				light2.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0x0040ff } ) ) );
				scene.add( light2 );

				light3 = new THREE.PointLight( 0x80ff80, 400 );
				light3.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0x80ff80 } ) ) );
				scene.add( light3 );

				light4 = new THREE.PointLight( 0xffaa00, 400 );
				light4.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0xffaa00 } ) ) );
				scene.add( light4 );

				//renderer

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				//stats

				stats = new Stats();
				document.body.appendChild( stats.dom );

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				const time = Date.now() * 0.0005;
				const delta = clock.getDelta();

				if ( object ) object.rotation.y -= 0.5 * delta;

				light1.position.x = Math.sin( time * 0.7 ) * 30;
				light1.position.y = Math.cos( time * 0.5 ) * 40;
				light1.position.z = Math.cos( time * 0.3 ) * 30;

				light2.position.x = Math.cos( time * 0.3 ) * 30;
				light2.position.y = Math.sin( time * 0.5 ) * 40;
				light2.position.z = Math.sin( time * 0.7 ) * 30;

				light3.position.x = Math.sin( time * 0.7 ) * 30;
				light3.position.y = Math.cos( time * 0.3 ) * 40;
				light3.position.z = Math.sin( time * 0.5 ) * 30;

				light4.position.x = Math.sin( time * 0.3 ) * 30;
				light4.position.y = Math.cos( time * 0.7 ) * 40;
				light4.position.z = Math.sin( time * 0.5 ) * 30;

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - lights - rect area light</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - THREE.RectAreaLight<br/>
			by <a href="http://github.com/abelnation" target="_blank" rel="noopener">abelnation</a>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import Stats from 'three/addons/libs/stats.module.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { RectAreaLightHelper } from 'three/addons/helpers/RectAreaLightHelper.js';
			import { RectAreaLightUniformsLib } from 'three/addons/lights/RectAreaLightUniformsLib.js';

			let renderer, scene, camera;
			let stats, meshKnot;

			init();

			function init() {

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animation );
				document.body.appendChild( renderer.domElement );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 0, 5, - 15 );

				scene = new THREE.Scene();

				RectAreaLightUniformsLib.init();

				const rectLight1 = new THREE.RectAreaLight( 0xff0000, 5, 4, 10 );
				rectLight1.position.set( - 5, 5, 5 );
				scene.add( rectLight1 );

				const rectLight2 = new THREE.RectAreaLight( 0x00ff00, 5, 4, 10 );
				rectLight2.position.set( 0, 5, 5 );
				scene.add( rectLight2 );

				const rectLight3 = new THREE.RectAreaLight( 0x0000ff, 5, 4, 10 );
				rectLight3.position.set( 5, 5, 5 );
				scene.add( rectLight3 );

				scene.add( new RectAreaLightHelper( rectLight1 ) );
				scene.add( new RectAreaLightHelper( rectLight2 ) );
				scene.add( new RectAreaLightHelper( rectLight3 ) );

				const geoFloor = new THREE.BoxGeometry( 2000, 0.1, 2000 );
				const matStdFloor = new THREE.MeshStandardMaterial( { color: 0xbcbcbc, roughness: 0.1, metalness: 0 } );
				const mshStdFloor = new THREE.Mesh( geoFloor, matStdFloor );
				scene.add( mshStdFloor );

				const geoKnot = new THREE.TorusKnotGeometry( 1.5, 0.5, 200, 16 );
				const matKnot = new THREE.MeshStandardMaterial( { color: 0xffffff, roughness: 0, metalness: 0 } );
				meshKnot = new THREE.Mesh( geoKnot, matKnot );
				meshKnot.position.set( 0, 5, 0 );
				scene.add( meshKnot );

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.target.copy( meshKnot.position );
				controls.update();

				//

				window.addEventListener( 'resize', onWindowResize );

				stats = new Stats();
				document.body.appendChild( stats.dom );

			}

			function onWindowResize() {

				renderer.setSize( window.innerWidth, window.innerHeight );
				camera.aspect = ( window.innerWidth / window.innerHeight );
				camera.updateProjectionMatrix();

			}

			function animation( time ) {

				meshKnot.rotation.y = time / 1000;

				renderer.render( scene, camera );

				stats.update();

			}

		</script>
	</body>
</html>
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - lights - spotlight</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - spotlight<br />
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			let renderer, scene, camera;

			let spotLight, lightHelper;

			init();

			function init() {

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFSoftShadowMap;


				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1;

				renderer.setAnimationLoop( render );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 0.1, 100 );
				camera.position.set( 7, 4, 1 );

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 2;
				controls.maxDistance = 10;
				controls.maxPolarAngle = Math.PI / 2;
				controls.target.set( 0, 1, 0 );
				controls.update();

				const ambient = new THREE.HemisphereLight( 0xffffff, 0x8d8d8d, 0.15 );
				scene.add( ambient );

				const loader = new THREE.TextureLoader().setPath( 'textures/' );
				const filenames = [ 'disturb.jpg', 'colors.png', 'uv_grid_opengl.jpg' ];

				const textures = { none: null };

				for ( let i = 0; i < filenames.length; i ++ ) {

					const filename = filenames[ i ];

					const texture = loader.load( filename );
					texture.minFilter = THREE.LinearFilter;
					texture.magFilter = THREE.LinearFilter;
					texture.colorSpace = THREE.SRGBColorSpace;

					textures[ filename ] = texture;

				}

				spotLight = new THREE.SpotLight( 0xffffff, 100 );
				spotLight.position.set( 2.5, 5, 2.5 );
				spotLight.angle = Math.PI / 6;
				spotLight.penumbra = 1;
				spotLight.decay = 2;
				spotLight.distance = 0;
				spotLight.map = textures[ 'disturb.jpg' ];

				spotLight.castShadow = true;
				spotLight.shadow.mapSize.width = 1024;
				spotLight.shadow.mapSize.height = 1024;
				spotLight.shadow.camera.near = 1;
				spotLight.shadow.camera.far = 10;
				spotLight.shadow.focus = 1;
				scene.add( spotLight );

				lightHelper = new THREE.SpotLightHelper( spotLight );
				scene.add( lightHelper );

				//

				const geometry = new THREE.PlaneGeometry( 200, 200 );
				const material = new THREE.MeshLambertMaterial( { color: 0xbcbcbc } );

				const mesh = new THREE.Mesh( geometry, material );
				mesh.position.set( 0, - 1, 0 );
				mesh.rotation.x = - Math.PI / 2;
				mesh.receiveShadow = true;
				scene.add( mesh );

				//

				new PLYLoader().load( 'models/ply/binary/Lucy100k.ply', function ( geometry ) {

					geometry.scale( 0.0024, 0.0024, 0.0024 );
					geometry.computeVertexNormals();

					const material = new THREE.MeshLambertMaterial();

					const mesh = new THREE.Mesh( geometry, material );
					mesh.rotation.y = - Math.PI / 2;
					mesh.position.y = 0.8;
					mesh.castShadow = true;
					mesh.receiveShadow = true;
					scene.add( mesh );

				} );

				window.addEventListener( 'resize', onWindowResize );

				// GUI

				const gui = new GUI();

				const params = {
					map: textures[ 'disturb.jpg' ],
					color: spotLight.color.getHex(),
					intensity: spotLight.intensity,
					distance: spotLight.distance,
					angle: spotLight.angle,
					penumbra: spotLight.penumbra,
					decay: spotLight.decay,
					focus: spotLight.shadow.focus,
					shadows: true
				};

				gui.add( params, 'map', textures ).onChange( function ( val ) {

					spotLight.map = val;

				} );

				gui.addColor( params, 'color' ).onChange( function ( val ) {

					spotLight.color.setHex( val );

				} );

				gui.add( params, 'intensity', 0, 500 ).onChange( function ( val ) {

					spotLight.intensity = val;

				} );


				gui.add( params, 'distance', 50, 200 ).onChange( function ( val ) {

					spotLight.distance = val;

				} );

				gui.add( params, 'angle', 0, Math.PI / 3 ).onChange( function ( val ) {

					spotLight.angle = val;

				} );

				gui.add( params, 'penumbra', 0, 1 ).onChange( function ( val ) {

					spotLight.penumbra = val;

				} );

				gui.add( params, 'decay', 1, 2 ).onChange( function ( val ) {

					spotLight.decay = val;

				} );

				gui.add( params, 'focus', 0, 1 ).onChange( function ( val ) {

					spotLight.shadow.focus = val;

				} );


				gui.add( params, 'shadows' ).onChange( function ( val ) {

					renderer.shadowMap.enabled = val;

					scene.traverse( function ( child ) {

						if ( child.material ) {

							child.material.needsUpdate = true;

						}

					} );

				} );

				gui.open();

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function render() {

				const time = performance.now() / 3000;

				spotLight.position.x = Math.cos( time ) * 2.5;
				spotLight.position.z = Math.sin( time ) * 2.5;

				lightHelper.update();

				renderer.render( scene, camera );

			}

		</script>

	</body>

</html>
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - lights - spot light</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - SpotLights<br/>
			by <a href="http://master-domain.com" target="_blank" rel="noopener">Master James</a>
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">
			import * as THREE from 'three';
			import TWEEN from 'three/addons/libs/tween.module.js';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

			const renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );

			const camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 0.1, 100 );

			const controls = new OrbitControls( camera, renderer.domElement );

			const scene = new THREE.Scene();

			const matFloor = new THREE.MeshPhongMaterial( { color: 0x808080 } );
			const matBox = new THREE.MeshPhongMaterial( { color: 0xaaaaaa } );

			const geoFloor = new THREE.PlaneGeometry( 100, 100 );
			const geoBox = new THREE.BoxGeometry( 0.3, 0.1, 0.2 );

			const mshFloor = new THREE.Mesh( geoFloor, matFloor );
			mshFloor.rotation.x = - Math.PI * 0.5;
			const mshBox = new THREE.Mesh( geoBox, matBox );

			const ambient = new THREE.AmbientLight( 0x444444 );

			const spotLight1 = createSpotlight( 0xFF7F00 );
			const spotLight2 = createSpotlight( 0x00FF7F );
			const spotLight3 = createSpotlight( 0x7F00FF );

			let lightHelper1, lightHelper2, lightHelper3;

			function init() {

				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFSoftShadowMap;

				camera.position.set( 4.6, 2.2, - 2.1 );

				spotLight1.position.set( 1.5, 4, 4.5 );
				spotLight2.position.set( 0, 4, 3.5 );
				spotLight3.position.set( - 1.5, 4, 4.5 );

				lightHelper1 = new THREE.SpotLightHelper( spotLight1 );
				lightHelper2 = new THREE.SpotLightHelper( spotLight2 );
				lightHelper3 = new THREE.SpotLightHelper( spotLight3 );

				mshFloor.receiveShadow = true;
				mshFloor.position.set( 0, - 0.05, 0 );

				mshBox.castShadow = true;
				mshBox.receiveShadow = true;
				mshBox.position.set( 0, 0.5, 0 );

				scene.add( mshFloor );
				scene.add( mshBox );
				scene.add( ambient );
				scene.add( spotLight1, spotLight2, spotLight3 );
				scene.add( lightHelper1, lightHelper2, lightHelper3 );

				document.body.appendChild( renderer.domElement );
				window.addEventListener( 'resize', onWindowResize );

				controls.target.set( 0, 0.5, 0 );
				controls.maxPolarAngle = Math.PI / 2;
				controls.minDistance = 1;
				controls.maxDistance = 10;
				controls.update();

			}

			function createSpotlight( color ) {

				const newObj = new THREE.SpotLight( color, 10 );

				newObj.castShadow = true;
				newObj.angle = 0.3;
				newObj.penumbra = 0.2;
				newObj.decay = 2;
				newObj.distance = 50;

				return newObj;

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function tween( light ) {

				new TWEEN.Tween( light ).to( {
					angle: ( Math.random() * 0.7 ) + 0.1,
					penumbra: Math.random() + 1
				}, Math.random() * 3000 + 2000 )
					.easing( TWEEN.Easing.Quadratic.Out ).start();

				new TWEEN.Tween( light.position ).to( {
					x: ( Math.random() * 3 ) - 1.5,
					y: ( Math.random() * 1 ) + 1.5,
					z: ( Math.random() * 3 ) - 1.5
				}, Math.random() * 3000 + 2000 )
					.easing( TWEEN.Easing.Quadratic.Out ).start();

			}

			function animate() {

				tween( spotLight1 );
				tween( spotLight2 );
				tween( spotLight3 );

				setTimeout( animate, 5000 );

			}

			function render() {

				TWEEN.update();

				if ( lightHelper1 ) lightHelper1.update();
				if ( lightHelper2 ) lightHelper2.update();
				if ( lightHelper3 ) lightHelper3.update();

				renderer.render( scene, camera );

				requestAnimationFrame( render );

			}

			init();
			render();
			animate();

		</script>
	</body>
</html>
